namespace ExploringGroversSearch { open Microsoft.Quantum.Arrays; open Microsoft.Quantum.Canon; open Microsoft.Quantum.Convert; open Microsoft.Quantum.Diagnostics; open Microsoft.Quantum.Intrinsic; operation MarkColorEquality(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl { within { for (q0, q1) in Zipped(c0, c1) { CNOT(q0, q1); } } apply { (ControlledOnInt(0, X))(c1, target); } } operation MarkValidVertexColoring( edges : (Int, Int)[], colorsRegister : Qubit[], target : Qubit ) : Unit is Adj+Ctl { let nEdges = Length(edges); let colors = Chunks(2, colorsRegister); use conflictQubits = Qubit[nEdges]; within { for ((start, end), conflictQubit) in Zipped(edges, conflictQubits) { MarkColorEquality(colors[start], colors[end], conflictQubit); } } apply { (ControlledOnInt(0, X))(conflictQubits, target); } } @EntryPoint() operation ShowColoringValidationCheck() : Unit { let nVertices = 5; let edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (3, 4)]; let coloring = [false, false, true, false, false, true, true, true, false, true]; use (coloringRegister, target) = (Qubit[2 * nVertices], Qubit()); ApplyPauliFromBitString(PauliX, true, coloring, coloringRegister); MarkValidVertexColoring(edges, coloringRegister, target); let isColoringValid = M(target) == One; Message($"The coloring is {isColoringValid ? "valid" | "invalid"}"); ResetAll(coloringRegister); } } 